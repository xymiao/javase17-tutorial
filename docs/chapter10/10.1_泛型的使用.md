# Java 17 中的泛型基础知识点

# 思维导图

![image-20211211095226856](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211095226856.png)

# 泛型 （generics）的历史

Java 是在 JDK 1.5 之后支持的泛型。泛型类型可以增强类型对象操作， 并且增加编译时的类型安全性， 并且为集合框架增加了编译时类型的安全性。 消除了对应的转换的繁琐工作。

对于 Java 1.0 之后都考虑加入到泛型中了，但是一直没有找到好的解决方案， 这个时候一个叫做 Martin Odersky 的人， 他是 Scala 语言的创造者，在刚刚发布的 Java 语言基础上扩展了泛型、函数式编程等功能， 该语言基于 JVM，该语言的名字是 Pizza。 再后来 Java 的语言开发团队就与他进行合作， 开发了新的项目 Generic Java。这个项目的目的是给 Java 增加泛型的支持， 但是并没有引入对应的函数式编程功能。经过了几个大版本的迭代， 终于在 Java 1.5 中引入了泛型。 

对于 Java 中的泛型， 当时引入只要有一个最大的问题就是如何向之前的版本进行兼容，对于增加泛型来说主要有两种方案实施。

1. 进行 Java 的 JVM 改造， 是编译成的字节码支持泛型。 
2. 仅在编译时判断泛型信息， 编译后把泛型信息抹去， 用边界信息进行代替。

对于当时来说， Java 已经有了庞大的用于量，为了更好的兼容低版本， 所以不会选用第一种方案。对于当时的 .Net 来说选用了第一种方案， 也就是不向低版本兼容。 这也是那几年慢慢的用 .Net 人少了。 升级太太太麻烦了。

# 为什么使用泛型

泛型可以使类型（类或者接口）在定义类、接口和方法时成为参数。它和方法声明中的形参比较相似。类型参数提供了一种重用具有不同输入的相同代码的方法，不同之处在， 形式参数的输入是值， 而泛型的类型参数是输入的类型。

与非泛型代码相比， 泛型代码有以下的优点：

- 编译时更严格的类型检查。 Java 编译器通过对代码的应用泛型类型检查，并在代码违反泛型类型时发出错误的信息，对于修复错误的信息， 编译时永远比运行时更加容易，运行时有时是很难找到的。
- 消除类型转换。 不使用泛型时， 需要进行强制类型转换，而使用泛型是则不需要。 
- 能够使程序实现通用的算法。

# 泛型的格式

## 类型参数命名约定

按照惯例，类型参数名称是单个大写字母。这与您已经知道的变量命名约定形成了鲜明的对比，并且有充分的理由：如果没有此约定，则很难区分类型变量与普通类或接口名称之间的区别。

最常用的类型参数名称是：

- E - Element（由 Java Collections Framework 广泛使用）
- K - 键
- N - 数字
- T - 类型
- V - 值
- S，U，V，R 等

## 接口

```java
[修饰符]  interface  InterfaceName<E>{
	//接口内使用 E
}
public interface Test<T>{
    public void add(T s);
}
```

## 类

```java
[修饰符]  class  className<E>{
	//接口内使用 E
}
public class TestClass<T>{
    public void plus(T t);
}
```

编写一个简单的例子：

![image-20211211092947963](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211092947963.png)

编写测试方法:

![image-20211211093134648](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211093134648.png)

对于泛型来说可以是任何类型的定义， 上面使用了字符串， 当然也可以使用其他的封装类型和类的对象。

看一个 class 的例子：

![image-20211211093530024](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211093530024.png)

对于方法中的add(T t); 这个就是使用泛型的第三种方式， 方法中使用泛型。 

如果泛型中定义了 Integer 类型，但是在使用中， 使用了非 Integer 类型的值， 就会出现错误信息。 

![image-20211211093729854](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211093729854.png)

编译的时候错误信息：

![image-20211211093814316](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211093814316.png)

对于包  java.util 中， 大量的看到 E 的泛型类型。 比方说 List<E> 和 ArrayList<E> 这些都是集合中常见的使用方法。 在没有泛型的时候需要来回强转。 

**没有使用泛型的方式**

![image-20211211094336240](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211094336240.png)

上面出现的警告是因为应该使用泛型对象的类， 没有进行泛型化。 只是警告信息， 这里演示有泛型和没有泛型的区别。 

为了兼容之前的版本， 没有写泛型的使用，会把默认值设置为 Object 类型， 因为 Object 是所有对象的父类。 

![image-20211211094535151](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211094535151.png)

**使用泛型的方式**

![image-20211211095009911](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211095009911.png)

赋值的时候， 我们可以看到使用泛型之后， add 方法就会和泛型类型一致的数据。 

![image-20211211094912038](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211211094912038.png)

从这可以看出了。 避免来回强制转换， 另外是能够增加程序的健壮性， 不会出现因为编写疏忽而出现类型错误的情况。 

以上只是泛型的最简单的用法， 还有很多复杂的使用方式， 另外开一篇进行说明了。



关注， 点赞， 收藏。 后续更多知识点。 

每篇一句： 软件并不是在集成开发环境（IDE）或其他工具上设计出来的， 它是在我们大脑中想象和创造出来的。 对于程序设计来说， 就是解决问题， 它需要发明、创造和灵感。 