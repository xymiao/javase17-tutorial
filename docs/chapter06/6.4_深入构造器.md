# Java 17 的构造器

# 思维导图

![image-20211201094230473](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201094230473.png)

先来说说什么是构造器（Constructor）， 构造器有不同的叫法。 分别为： 构造函数， 构造方法。这都是说的同一种知识点。也就是不同的方言而已。有人称馒头叫馍。但它还是由面粉加工而成。不同的语言也都有不同的语法。 在 Java 中使用 new 关键字， 进行构造器的调用。 

并且在 Java 中你可以认为构造方法， 是一个特殊的方法。 默认返回对象本身的方法， 并且不需要 return 关键字。

## 构造方法的语法规则

```java
[修饰符] 类名([1...n 参数]){
    //构造方法一些列的操作
}
```

**修饰符：** 可以使用 public、protected、private 三种修饰方法。

修饰符的作用域从小到大排序为： private < protected < public。

private: 只能当前类进行调用和使用。 作用域是当前 class 访问。

protected：对于当前类和相同包中以及子类都可以访问。

public: 所有可使用的类中都可使用。 也就是只要用我就可以访问。 All in。

# 默认构造器

在类中， 可以不显式的编写构造器， 这个时候， 编译器在编译成字节码的时候会自动把构造器生成到字节码文件中也就是 .class 文件中。

这里举个例子， 例子中编译 .class 之后， 使用官方的反编译工具 javap 进行反编译源代码，查看效果，当然也可以使用二进制类的编辑器查看 .class 的代码。

**javap 的用法**

![image-20211201102451223](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201102451223.png)

例子如下：

![image-20211201102528447](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201102528447.png)我们写代码的时候， 并没有定义构造方法， 但是在反编译 .class 文件的时候， 却看到了一个默认的 `public Demo14Construct `  的构造方法。可以看到该构造方法没有返回值， 因为构造方法并没有显式的定义返回值， 默认的规范为返回该对象本身。并且构造方法的名字必须和类名一致， 接下来说明这一点。 

定义了类并包含了构造方法， 我们在什么时候使用的构造方法的呢。 接下来我们写个测试类。

使用的方式就是 `new 构造方法 `，因为构造方法和类名一致的规则， 所以就是 `new 一个类名`， 并且在new 一个构造方法的时候， 也可以称为创建一个该类的实例。

```java
new Demo14ConstructTest();
```

这就是最简单用法，但是这样用也只是知道他的用法而已， 在实际开发中不会这样使用，没有意义。

![image-20211201103206958](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201103206958.png)

调用该构造方法， 并不会有任何的反馈。 当你需要构造函数中处理一些预处理语句的时候， 就可以显式的进行指定。

例如：

![image-20211201103836059](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201103836059.png)

这里显式的调用之后， 构造方法中就可以编写你想编写的代码。 初始化变量啊， 定义一些业务规则之类的。 

根据规范来说， 既然构造方法返回了类本身的一个实例。 所以， 就可以使用该类进行接收该实例。

格式如下： ` Demo15Construct d15 = new Demo15Construct();`

修改单元测试代码： 

![image-20211201104255152](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201104255152.png)

这就是对象实例化的一个简单过程。 

# 有参数的构造方法

代码并不是纯粹的为了写代码， 而是为了解决实际的现实问题。 我想骑自行车， 就要有自行车， 我想开摩托车， 就要有摩托车。所以， 构造方法中可以传入你想开的车的类型。 然后调用开车方法。 

![image-20211201110301664](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201110301664.png)

需要注意的是： 如果有显式的构造方法， 不管是无参数方法， 还是有参数的构造方法， 都不会生成默认的构造方法。 根据这个规则， 如果你编写了有参数的构造方法，又没有指定无参数的构造方法时， 就无法使用 `new Demo16Car();` 的用法了。

![image-20211201111220314](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201111220314.png)

编译都过不去， 在编写代码的 IDE中都会直接提示语法错误的。

除了这种不能使用之外， 对于修饰符修饰 private 的构造器也无法调用构造方法。

![image-20211201111532675](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201111532675.png)

编译虽然过去， 但是运行的时候会有错误。 并且这只是在本类的情况下， 如果在其他类会直接无法使用。 语法错误。

![image-20211201111759453](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202112/image-20211201111759453.png)

因为 package 没有讲解， 所以针对构造的 protected 修饰符不做讲解， 只需要理解， 使用该修饰符的时候， 不是你想 new 就能 new 处来对象的就行了。 



本章构造器的说明就到这了。 2021 即将结束了。 这剩下的一个月你准备怎么过呢？ 
