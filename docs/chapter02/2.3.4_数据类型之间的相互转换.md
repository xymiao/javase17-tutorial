## 基础数据类型的相互转换

在 Java 中，对于基础的数据类型转换是学习的重点之一， 只有知道了转换规则才能避免转换过程中遇到的一些坑。本篇就来说说数据类型之前的转换规则。

对于基础类型的转换有两种方式。 一种由小到大的转换， 不会丢失精度。另一种由大变小的强制转换， 有可能有丢失精度和出错。

对于基础类型的转换， Java 语言一共提供了 7 种数值类型进行相互转换。

根据现有规则把数据类型的转换分为了两种情况， 一种是自动转换， 另一种是强制转换。

**转换规则（从小到大）**

![image-20211110120535870](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211110120535870.png)

# 自动转换

从小转到大的范围情况下可以自动转换， 也可以叫作隐式转换。按照数据类型的从小到大自动进行转换。

对于自动转换的规则遵守下面两个规则：

1. 对于需要转换的数据类型必须要是转换前的数据类型兼容转换后的数据类型。
2. 转换后的数据类型的范围必须比转换前的数据类型范围大。

代码演示：

![image-20211110155422749](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211110155422749.png)

```java
byte byteValue = 'a';  // 'a' ASCII is 97
short shortValue = byteValue;  // 97
int intValue = shortValue; // 97
long longValue = intValue; // 97
float floatValue = longValue; // 97
double doubleValue = floatValue; // 97
System.out.println(doubleValue);  //97

char charValue = 'a'; 
int intCharValue = charValue; // 97
System.out.println(intCharValue);
```

运行查看：

![image-20211110155514338](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211110155514338.png)‘

以上是一级一级的往上转换。 所以不会出现问题， 哪怕是跳级也是可以的。

比方说：

```java
byte byteVal = 'b';
int intVal  = byteVal;
```

或者是：

```java
int intVal2 = 100;
double d = intVal2;
```

这样也没有问题。但是如果是下面这样就有问题了。 

```java
long longVal = 100;
//这里会报错。Type mismatch: cannot convert from long to int
int intVal3 = longVal; 
```

如果非要这样转，并且转换前的数据也是能够和更小类型兼容， 就需要使用强制转换。 

# 强制转换

强制转换， 代表着数据类型的转换默认无法进行转换， 所以需要显式的进行类型转换。 

强制类型转换的格式为在变量的名字前面加上括号写上基础类型。

格式：`(需要转换的基础类型)变量；`

```java
long longValWait = 100;
int intConvert = (long)longValWait;
```

想要详细的了解强制类型转换， 需要先了解下面的这个图：

![image-20211111080227447](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211111080227447.png)

占用字节大的数据类型转换字节小的就需要强制转换。 并且转换的时候需要注意丢失精度的问题。

让我看一个会丢失精度的代码例子：

![image-20211111084050243](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211111084050243.png)

定义个 short ， 规矩定义的规则我们可以得知 byte 的取值范围是： -128 到  127。所以当我们定义了不在改取值范围的值时， 比方例子中的 128  就会丢失精度。 让我们看一下丢失的数值跑哪去了。 

首先可以看到 short 的字节是 2 ， 也就是占用 16 bit，但是 byte 只占用 1 位，也就是 8 bit。所以在转换的时候， short 的前 8 bit 被丢了。

![image-20211111082211990](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211111082211990.png)

并且在类型中， 最左侧的是符号位。8 位的符号位也就是1。在计算机处理二进制数的时候， 符号位 1 代表负值， 0 代表正值。所以后面 7 位代表数据的值。又因为负数在计算机中以补码形式存在的。 所以还需要转换成原码进行计算。也就是符号位不变的情况下，将后面 7 位二进制数即按位取反。并在最后一位加 1。

![image-20211111083812316](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211111083812316.png)

这个时候就遇到了一个特殊的情况也就是 -128 的来源。因为 +0 和 -0 是一样的。但是对于 0 带符号来说没有意义。而且会有 [0000 0000] 和 [1000 0000] 两个原码。所以也就有了现在的补码。

补码是为了解决 0 的符号两个编码的问题。在补码运算中 [1000 0000] 就是 -128。也就得出来了我们的输出值 -128。

让我们看一下 129 的计算方式：

首先知道 129 的二进制是 [1000 0001]，转换成 8 bit之后就变成首尾符号位为负数，

然后得出补码 [11111 1111] 也就是 -127 了。

![image-20211111085234761](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211111085234761.png)

从这里我们也就可以根据补码知道了 byte 数据类型的取值范围：

[1111 1111] ~  [0111 1111] 也就是 -128 ~ 127。



这里总结一下原码， 反码，补码的大概含义。

**原码**：原码就是用第一位表示符号，其余位表示值，就如同上面的 16 位 [0000 0000 1000 0001]。

**反码：** 正数的反码是原码本身， 负数的反码是在原码的基础上， 其余各个位取反。

上面的值就变成：[0000 0000 1000 0001]

**补码：**正数的补码就是其本身， 负数的补码就是在原码的基础上， 其余的各位都取反，并在最后一位 + 1。也就是在反码的基础上 +1。

最终的补码变成：[0000 0000 1000 0001] 也就是129。



从这里也就可以看出来， 我们在进行数据处理的时候尽量不要用位数大的数据类型转换成小的数据类型， 除非你很清楚这样转换没有问题。

## 浮点类型的强制转换

以上说的都是整数的强制转换问题， 浮点型的也可以转换。 这里做两个演示。

![image-20211111093352175](https://cdn.jsdelivr.net/gh/xymiao/xymiaocdn/res/2021/202111/image-20211111093352175.png)

这里就是要引入浮点和整型进行转换或者运算的时候出现的问题。对于金融来说， 很少使用 float 和 double 进行运算和使用。推荐使用 BigDecimal 对象。具体为什么。了解原理可以参阅 ： **IEEE 754标准**。后期有时间再写一篇详细的原因。主要还是二进制位的运算区别。



数据类型的转换， 先说到这里吧。 关注我。 后续更多基础到实战的内容。虽慢但永不停更。

